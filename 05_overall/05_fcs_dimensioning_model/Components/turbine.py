import CoolProp.CoolProp as CP
from scipy.interpolate import griddata
from scipy.interpolate import RegularGridInterpolator

import numpy as np
from parameters import Mass_Parameters



class Turbine:
    def __init__(self, mass_estimator: Mass_Parameters, isentropic_efficiency=0.65,
                 air_mass_flow_kg_s=1, temperature_in_K=293.15, pressure_in_Pa=1.013e5, pressure_out_Pa=1.013e5,
                 nominal_BoP_pressure_drop_Pa=0.15*1e5, nominal_air_flow_kg_s=0.130, reference_ambient_conditions=(1.01325 * 1e5, 298.15),
                 turbine_map=None):

        self.isentropic_efficiency = isentropic_efficiency
        self.air_mass_flow_kg_s = air_mass_flow_kg_s
        self.pressure_in_Pa = pressure_in_Pa
        self.temperature_in_K = temperature_in_K
        self.pressure_out_Pa = pressure_out_Pa
        self.nominal_pressure_drop_Pa = nominal_BoP_pressure_drop_Pa
        self.nominal_air_flow_kg_s = nominal_air_flow_kg_s
        self.turbine_map = turbine_map

        # Reference ambient conditions
        self.reference_pressure_Pa, self.reference_temperature_K = reference_ambient_conditions

        # Check if mass data for the turbine exists in the mass estimator
        if 'Turbine' not in mass_estimator.masses_FCM_depended:
            raise ValueError("Component 'Turbine' not found in mass estimator's dependent masses.")

        # Retrieve mass data from the mass estimator instance
        self.mass_by_power_kg_kW = mass_estimator.masses_FCM_depended['Turbine']

    def calculate_power(self) -> float:
        """
        Calculate the mechanical power generated by the turbine.

        Returns:
        - turbine_shaft_power_W: The mechanical power generated by the turbine in Watts.
        """
        # Calculate the specific enthalpy before and after the turbine
        specific_enthalpy_in_J_kg = CP.PropsSI('H', 'T', self.temperature_in_K, 'P', self.pressure_in_Pa, 'Air')
        specific_enthalpy_out_J_kg = CP.PropsSI('H', 'T', self.calculate_T_out(), 'P', self.pressure_out_Pa, 'Air')

        # Compute the isentropic power
        turbine_isentropic_power_W = self.air_mass_flow_kg_s * (specific_enthalpy_in_J_kg - specific_enthalpy_out_J_kg)

        # Use the defined efficiency since turbine_map is None
        efficiency = self.isentropic_efficiency

        # Calculate the turbine shaft power using the fixed efficiency
        turbine_shaft_power_W = turbine_isentropic_power_W * efficiency

        return turbine_shaft_power_W


    def calculate_T_out(self) -> float:
        """
        Calculate the outlet temperature of the isentropic expansion by the turbine.

        Returns:
        - temperature_out_K: Outlet temperature in K at the turbine outlet.
        """
        specific_heat_ratio = CP.PropsSI('Cpmolar', 'T', self.temperature_in_K, 'P', self.pressure_in_Pa, 'Air') / \
                              CP.PropsSI('Cvmolar', 'T', self.temperature_in_K, 'P', self.pressure_in_Pa, 'Air')

        # Temperature calculation using efficiency directly
        temperature_out_K = self.temperature_in_K * (
                (self.pressure_out_Pa / self.pressure_in_Pa) ** ((specific_heat_ratio - 1) / specific_heat_ratio)
        ) ** self.isentropic_efficiency

        return temperature_out_K


    def calculate_corrected_mass_flow(self) -> float:
        """
        Calculate the corrected mass flow rate of the turbine based on the reference ambient conditions.

        Returns:
        - corrected_mass_flow_kg_s: The corrected mass flow rate in kg/s.
        """
        corrected_mass_flow_kg_s = self.air_mass_flow_kg_s * (self.reference_pressure_Pa / self.pressure_in_Pa) \
            * (self.temperature_in_K / self.reference_temperature_K)**0.5

        return corrected_mass_flow_kg_s

    def get_efficiency(self) -> float:
        """

        Returns:
        - efficiency: The efficiency at the current operating point.
        """
        if self.turbine_map is not None:
            return self._interpolate_efficiency()
        else:
            return self.isentropic_efficiency

    def _interpolate_efficiency(self) -> float:
        """
        Interpolates the efficiency from the turbine map based on the current operating point,
        with boundary adjustments for out-of-range values.

        Returns:
        - Efficiency at the given operating point as a float.
        """
        # Calculate the pressure ratio and corrected mass flow in g/s
        pressure_ratio = self.pressure_in_Pa / self.pressure_out_Pa
        corrected_mass_flow_g_s = self.calculate_corrected_mass_flow() * 1000  # Convert to g/s

        # Get unsorted 1D arrays defining the grid for pressure ratios and mass flows
        expansion_ratio_unsorted = self.turbine_map['expansion_ratio'][0, :]
        corrected_mass_flow_unsorted = self.turbine_map['corrected_mass_flow_g_s'][:, 0]

        # Sort each axis and reorder the efficiency data accordingly
        expansion_ratio_sorted_indices = np.argsort(expansion_ratio_unsorted)
        corrected_mass_flow_sorted_indices = np.argsort(corrected_mass_flow_unsorted)

        expansion_ratio_axis = expansion_ratio_unsorted[expansion_ratio_sorted_indices]
        corrected_mass_flow_axis = corrected_mass_flow_unsorted[corrected_mass_flow_sorted_indices]

        # Reorder the efficiency data to match sorted axes
        isentropic_efficiency_sorted = self.turbine_map['isentropic_efficiency'][corrected_mass_flow_sorted_indices, :]
        isentropic_efficiency_sorted = isentropic_efficiency_sorted[:, expansion_ratio_sorted_indices]

        # Clip values to the map bounds to avoid extrapolation
        pressure_ratio_clipped = np.clip(pressure_ratio, expansion_ratio_axis.min(), expansion_ratio_axis.max())
        corrected_mass_flow_clipped = np.clip(corrected_mass_flow_g_s, corrected_mass_flow_axis.min(),
                                              corrected_mass_flow_axis.max())

        # Create the interpolator with sorted data
        interpolator = RegularGridInterpolator(
            (corrected_mass_flow_axis, expansion_ratio_axis),
            isentropic_efficiency_sorted,
            bounds_error=False,
            fill_value=None  # Allows extrapolation if needed
        )

        # Interpolate the efficiency
        efficiency = interpolator((corrected_mass_flow_clipped, pressure_ratio_clipped))

        return efficiency.item() if efficiency.size else efficiency


    def calculate_mass(self) -> dict:
        """
        Calculate predicted mass of the turbine utilizing the mass_by_power_kg_kW dict of the class.

        Returns:
        - result: A dictionary containing:
            - "mean": Turbine mass in kg based on the mean value of mass_by_power_kg_kW.
            - "sd": Turbine mass in kg based on the standard deviation of mass_by_power_kg_kW.
        """
        turbine_shaft_power_W = self.calculate_power()
        turbine_mass_mean_kg = self.mass_by_power_kg_kW["mean"] * turbine_shaft_power_W / 1000
        turbine_mass_sd_kg = self.mass_by_power_kg_kW["sd"] * turbine_shaft_power_W / 1000
        return {
            "mean": turbine_mass_mean_kg,
            "sd": turbine_mass_sd_kg
        }
#
# # Example instantiation
# from cathode_model_run import Mass_Parameters, TurbineParameters
#
# # Instantiate Mass_Parameters to provide mass data
# mass_estimator = Mass_Parameters()
#
# # Create an instance of the Turbine class with a fixed efficiency
# turbine_instance = Turbine(
#     mass_estimator=mass_estimator,
#     isentropic_efficiency=0.65,       # Define a fixed efficiency
#     air_mass_flow_kg_s=0.1215,         # Example input mass flow rate in kg/s
#     temperature_in_K=444,        # Example inlet temperature in Kelvin
#     pressure_in_Pa=2.48e5,            # Example inlet pressure in Pa
#     pressure_out_Pa=0.63e5,           # Example outlet pressure in Pa
#     turbine_map=None                  # No turbine map
# )
#
# # Calculate and print the turbine power output
# turbine_power = turbine_instance.calculate_power()
# print(f"Turbine Power Output: {turbine_power:.2f} W")
#
# # Calculate and print the turbine outlet temperature
# temperature_out = turbine_instance.calculate_T_out()
# print(f"Turbine Outlet Temperature: {temperature_out:.2f} K")
