import CoolProp.CoolProp as CP
from scipy.interpolate import griddata
import numpy as np
from parameters import Mass_Parameters

class Turbine:

    def __init__(self, mass_estimator: Mass_Parameters, isentropic_efficiency=0.85,
                 air_mass_flow_kg_s=1, temperature_in_K=293.15, pressure_in_Pa=1.013e5, pressure_out_Pa=1.013e5,
                 nominal_BoP_pressure_drop_Pa=0.15*1e5, nominal_air_flow_kg_s=0.130, reference_ambient_conditions=(1.01325 * 1e5, 298.15),
                 turbine_map=None):

        self.isentropic_efficiency = isentropic_efficiency
        self.air_mass_flow_kg_s = air_mass_flow_kg_s
        self.pressure_in_Pa = pressure_in_Pa
        self.temperature_in_K = temperature_in_K
        self.pressure_out_Pa = pressure_out_Pa
        self.nominal_pressure_drop_Pa = nominal_BoP_pressure_drop_Pa
        self.nominal_air_flow_kg_s = nominal_air_flow_kg_s
        self.turbine_map = turbine_map

        # Assign the reference ambient conditions
        self.reference_pressure_Pa, self.reference_temperature_K = reference_ambient_conditions \
            if turbine_map is None else (self.turbine_map['reference_pressure_Pa'], self.turbine_map['reference_temperature_K'])

        # Ensure the component is available in masses_FCM_depended; raise error if missing
        if 'Turbine' not in mass_estimator.masses_FCM_depended:
            raise ValueError("Component 'Turbine' not found in mass estimator's dependent masses.")

        # Retrieve mass data from the mass_estimator instance
        self.mass_by_power_kg_kW = mass_estimator.masses_FCM_depended['Turbine']

    def calculate_power(self) -> float:
        """
        Calculate the mechanical power generated by the turbine using a real-world turbine map.

        Returns:
        - turbine_shaft_power_W: The mechanical power generated by the turbine in Watts.
        """
        # Calculate the specific enthalpy before and after the turbine
        specific_enthalpy_in_J_kg = CP.PropsSI('H', 'T', self.temperature_in_K, 'P', self.pressure_in_Pa, 'Air')
        specific_enthalpy_out_J_kg = CP.PropsSI('H', 'T', self.calculate_T_out(), 'P', self.pressure_out_Pa, 'Air')

        # Compute the isentropic power
        turbine_isentropic_power_W = self.air_mass_flow_kg_s * (specific_enthalpy_in_J_kg - specific_enthalpy_out_J_kg)

        # Determine the operating efficiency if a turbine map is provided
        if self.turbine_map is not None:
            efficiency, _ = self._interpolate_efficiency()
            turbine_shaft_power_W = turbine_isentropic_power_W * efficiency
        else:
            turbine_shaft_power_W = turbine_isentropic_power_W * self.isentropic_efficiency

        return turbine_shaft_power_W

    def calculate_corrected_mass_flow(self) -> float:
        """
        Calculate the corrected mass flow rate of the turbine based on the reference ambient conditions.

        Returns:
        - corrected_mass_flow_kg_s: The corrected mass flow rate in kg/s.
        """
        corrected_mass_flow_kg_s = self.air_mass_flow_kg_s * (self.reference_pressure_Pa / self.pressure_in_Pa) \
            * (self.temperature_in_K / self.reference_temperature_K)**0.5

        return corrected_mass_flow_kg_s

    def get_efficiency(self) -> float:
        """
        Public method to calculate and return the efficiency based on the turbine map.

        Returns:
        - efficiency: The interpolated efficiency at the current operating point.
        - operating_point: A list containing [expansion_ratio, corrected_mass_flow_g_s]
        """
        efficiency, operating_point = self._interpolate_efficiency()
        return efficiency, operating_point

    def _interpolate_efficiency(self) -> float:
        """
        Interpolates the efficiency from the turbine map based on the current operating point.

        Returns:
        - Efficiency at the given operating point.
        """
        pressure_ratio = self.pressure_in_Pa / self.pressure_out_Pa
        corrected_mass_flow_g_s = self.calculate_corrected_mass_flow() * 1000  # Convert to g/s

        # Assign the turbine map arrays and flatten to 1D
        map_pressure_ratio = self.turbine_map['expansion_ratio'].flatten()
        map_mass_flow_g_s = self.turbine_map['corrected_mass_flow_g_s'].flatten()
        map_efficiency = self.turbine_map['isentropic_efficiency'].flatten()

        # Interpolate the efficiency with a default small fill value for out-of-bound points
        efficiency = griddata(
            np.array([map_mass_flow_g_s, map_pressure_ratio]).T,
            map_efficiency,
            (corrected_mass_flow_g_s, pressure_ratio),
            method='linear',
            rescale=True,
            fill_value=1e-3  # Small default value when out of bounds
        )

        return efficiency.item(), [pressure_ratio, corrected_mass_flow_g_s]

    def calculate_T_out(self) -> float:
        """
        Calculate the outlet temperature of the isentropic expansion by the turbine.

        Returns:
        - temperature_out_K: T in K at the turbine outlet
        """
        # Compute the specific heat ratio of air
        specific_heat_ratio = CP.PropsSI('C', 'T', self.temperature_in_K, 'P', self.pressure_in_Pa, 'Air') / \
                              CP.PropsSI('O', 'T', self.temperature_in_K, 'P', self.pressure_in_Pa, 'Air')

        temperature_out_K = self.temperature_in_K * (((self.pressure_out_Pa / self.pressure_in_Pa) ** ((specific_heat_ratio - 1) / specific_heat_ratio) - 1) * self.isentropic_efficiency + 1)

        return temperature_out_K

    def calculate_mass(self) -> dict:
        """
        Calculate predicted mass of the turbine utilizing the mass_by_power_kg_kW dict of the class.

        Returns:
        - result: A dictionary containing:
            - "mean": Turbine mass in kg based on the mean value of mass_by_power_kg_kW.
            - "sd": Turbine mass in kg based on the standard deviation of mass_by_power_kg_kW.
        """
        turbine_shaft_power_W = self.calculate_power()
        turbine_mass_mean_kg = self.mass_by_power_kg_kW["mean"] * turbine_shaft_power_W / 1000
        turbine_mass_sd_kg = self.mass_by_power_kg_kW["sd"] * turbine_shaft_power_W / 1000
        return {
            "mean": turbine_mass_mean_kg,
            "sd": turbine_mass_sd_kg
        }

from cathode_model_run import Mass_Parameters, TurbineParameters

# Instantiate TurbineParameters to access turbine map
turbine_params = TurbineParameters()

# Instantiate Mass_Parameters to provide mass data
mass_estimator = Mass_Parameters()

# Create an instance of the Turbine class with the turbine map from TurbineParameters
turbine_instance = Turbine(
    mass_estimator=mass_estimator,
    isentropic_efficiency=turbine_params.isentropic_efficiency,
    air_mass_flow_kg_s=0.162,                      # Example input mass flow rate in kg/s
    temperature_in_K=350.15,                     # Example inlet temperature in Kelvin
    pressure_in_Pa=1.7e5,                          # Example inlet pressure in Pa
    pressure_out_Pa=0.77e5,                         # Example outlet pressure in Pa
    turbine_map=turbine_params.turbine_map       # Provide the turbine map from TurbineParameters
)

# Calculate the power output of the turbine
turbine_power = turbine_instance.calculate_power()
print(f"Turbine Power Output: {turbine_power:.2f} W")

# Calculate the corrected mass flow rate
corrected_mass_flow = turbine_instance.calculate_corrected_mass_flow()
print(f"Corrected Mass Flow Rate: {corrected_mass_flow*1000:.4f} g/s")

# Calculate the efficiency directly using the public method
efficiency, operating_point = turbine_instance.get_efficiency()
print(f"Interpolated Efficiency: {efficiency:.2f} at Operating Point - Expansion Ratio: {operating_point[0]:.2f}, Corrected Mass Flow: {operating_point[1]:.2f} g/s")


# Calculate the outlet temperature of the turbine
temperature_out = turbine_instance.calculate_T_out()
print(f"Turbine Outlet Temperature: {temperature_out:.2f} K")
